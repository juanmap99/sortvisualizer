<div class="modal-container">
    <div class="icon">
        <fa-icon (click)="closeModal()" [icon]="closeButton"></fa-icon>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 0">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
            <h1>Introducción</h1>
            <p>HeapSort es un algoritmo que ordena el array de forma in-place haciendo uso de Heaps; séanse las mismas
                MaxHeaps(cuando se busca ordenar de manera incremental) o MinHeaps(cuando se busca ordenar
                de manera decremental).
            </p>
            <p>La construcción de una heap se realiza a travez de un proceso que se lo conoce como <strong>heapificación</strong> de un array, lo que implica 
                tratar al mismo como si fuese la representación de un <strong>Árbol Binario Completo</strong>, en donde cada <strong>array[i]</strong>
                es un nodo que tiene a su <strong>hijo izquierdo</strong> en la posición <strong>i*2 + 1</strong> y a 
                su <strong>hijo derecho</strong> en la posición <strong>i*2 + 2</strong>. En el caso de una Max Heap, se debe cumplir a su vez
                con la condición que todo nodo padre tiene que ser mayor sus hijos, mientras que el caso de una Min Heap todo nodo padre debe
                ser menor a sus hijos. Al realizar esto, se cuenta con la garantía que array[0] contiene ya sea el valor mas grande(Max Heap) o
                el mas chico(MinHeap).
            </p>
            <p>
                A su vez, debido a que el mismo es una representación de un <strong>Árbol Binario Completo</strong> conocemos que:
            </p>
                <ul>
                    <li>Todos los niveles del árbol se encontraran llenos a excepción del último.</li>
                    <li>Los nuevos elementos se agregan siempre de izquierda a derecha.</li>
                    <li>El índice a partir del cual se encuentran las hojas del arbol es: (array length // 2)</li>
                </ul>
            <br>
            <h1>Análisis complejidad temporal</h1>
            <p>
                La complejidad temporal es de <strong>O(n Log<sub>2</sub>n)</strong> debido a que recorremos la totalidad
                del array;lo que lleva un tiempo de O(n); y sobre cada iteración se realiza una heapificación
                que consiste en hacer un <strong>BubbleDown</strong> del elemento en la primera posición, lo que conlleva
                un tiempo de O(Log<sub>2</sub>n) ya que se desplaza a traves de un árbol binario.
            </p>
            <br>
            <h1>Análisis complejidad espacial</h1>
            <p>
                La complejidad espacial es constante debido a que no solo el proceso de ordenamiento es <strong>in-place</strong>,
                sino que a su vez el proceso de heapificación se realiza sobre el mismo array.
            </p>
        </div>
    </div>

    <div class="modal-content-wrapper" *ngIf="curModalTab == 1">
        <div class="modal-content"
             [style.height]="modalHeight-90 + 'px'"
             [style.width]="modalWidth-40 + 'px'">
             <h1>Procedimiento</h1>
             <p>
                El procedimiento a traves del cual funciona el HeapSort cuenta con cierto grado de similitud al del BubbleSort en el sentido
                de que sobre cada iteración se busca por el elemento máximo o mínimo en el subconjunto restante. La diferencia
                principal radica en que el BubbleSort sobre cada iteración recorre la totalidad del subconjunto restante y realiza
                los desplazamientos necesarios en el camino; mientras que HeapSort lo que hace es tomar el elemento en la primera posición, coloca
                en su lugar el elemento en la ultima posición y realiza un <strong>Bubble down</strong> del elemento en la posicion 0 para garantizar que en la siguiente iteración
                se vuelva a contar con el elemento ya sea mas grande o mas pequeño en la primera posición.
            </p>
            <p>En base a esto, los pasos que se siguen son:</p>
            <ul>
                <li>Se construye una MaxHeap en el caso que se desee un orden inceremental, o una MinHeap en caso contrario.</li>
                <li>A través del paso anterior se cuenta con la certeza que el elemento mas grande(MaxHeap) o mas pequeño(MinHeap) se encuentra
                    en la posición inicial del array.
                </li>
                <li>Se reemplaza la posición del primer elemento por la del último.</li>
                <li>Se reduce el tamaño de la heap en 1 y realiza el Bubble down del elemento en la posición 0.</li>
                <li>Se repite el proceso hasta que solo quede un elemento en la heap.</li>
            </ul>
        </div>
    </div>
    <div class="lower-modal-section">
        <div class="hline-wrap">
            <div class="hline"></div>
        </div>
        <div class="interaction-wrapper">
            <a class="back-button"[style.visibility]="curModalTab == 0 ? 'hidden' : 'visible'"
            (click)="goPreviousPage()">&laquo; Previous</a>
            <a class="next-button"[style.visibility]="curModalTab == 1 ? 'hidden' : 'visible'" (click)="goNextPage()">Next &raquo;</a>       
        </div>
    </div>
</div>
